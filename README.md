
Z 现在还在设想阶段. 

#简介

ZxxLang 是一门文档风格通用编程语言. 初衷是混合文档和代码于一体并降低 shift 按键的使用频率.  ZxxLang 通过忽略不能识别的文本, 减少或替代和 shift 按键有关操作符来实现此目的.

	Z 减少 shift 按键频率的方法可能会让一些开发者难于接受, 但这是 Z 固守的特征

简便起见, 下文用 Z 替代 ZxxLang 进行描述.

Z 的语法比较宽松下面的几种输入风格都可以被正确识别:

```
var string s = 'hello word'

var [
	int x
	int y=5
	int z,i=4
]

var (
	float f = 9.0
)

var datetime (
	day = 20160202, now = 20160202T22:48:33
	orz = 20160202T22:48:33Z
)

proc hello string word =[
	echo 'hello ' word 
]
```

Z 支持用输入方括号替代圆括号, 因为方括号不用按住 shift 键, 便于输入. Z 提供的格式化工具会进行常规习惯转换. 

	Z 没有代码规范, 怎样写代码使用者自己说了算.
	代码规范是令人厌恶的事情.

Z 提供了源码格式美化工具, 如果你愿意使用, 上面的代码会转换成下面的样子

```
var string s = 'hello word'

var {
	int x
	int y=5
	int z,i=4
}

var float f = 9.0

var datetime {
	day = 20160202
	now = 20160202T22:48:33
	orz = 20160202T22:48:33Z
}

proc hello string word ={
	echo 'hello ' word 
}
```

#语素

学术上语素是构成语言的最小单位, Z 有两种语素:

	字面值 源码中的一段文本
	标识符 有格式要求的文本, 是具有明确语义的 Z 实体标记

Z 中它们是互斥的. Z 是这样确定语素的:

1. 是不是符合内建格式的字面值
2. 是不是预声明字面值
3. 是不是预声明标识符
4. 是不是能声明新标识符
5. 判定为 占位字面值

字面值和语素组成更大颗粒的 Z 实体, 表达式和语句.

#字面值

##预声明字面值

```
`
null      空值, 零值, 非真值
false     假
true      真
NaN       浮点类型 非数
infinite  浮点类型 无穷大
`
```

##格式字面值

包括  string, datetime, float, int 等格式的文本, 下文叙述.

##占位文本

空白符, 空行, 以及任意的文本. 

空白符包括 Space ' ', Tab '\t', CR '\r', LF '\n'. 空白符具有分隔符和占位作用.

#标识符

标识符由 UTF-8 编码的 Unicode 字符组成, 组成部分繁杂, 这里不详述. 第一个字符不能是数字, 中间不能含有空白符, 分隔符和控制符等特殊符号.

##预声明标识符

包括内建类型以及 Z 保留字, 下文详述.

##注释

注释是内建的标识符, 是对某个标识符或某行语句的说明. Z 有三种注释写法.

1. 尾注释以 '//' 开始, 直到行尾
2. 块注释以三个以上的减号 '-' 位于一行非空白符之首开始, 并以此结束.
3. 字符串值注释, 孤立的字符串值也会被当做注释.

```
// 这是一条尾注释, 可以分成连续的多行书写. 
// 纵观整个文本, 无法确定这条注释属于哪个标识符

---
这是个块注释, 可以多行书写.
纵观整个文本, 无法确定这条注释属于哪个标识符
---
proc sum int x,y,out int [
	'sum 返回 x + y 的和' // 此行注释归属于标识符 proc sum
	return x + y // 返回 x+y
]
```

依惯例, 注释最普遍的作用是生成文档. 从这个角度出发, Z 会忽略那无法确定归属的注释. 能向前归属到某个语句的注释被称作注释, 否则被称作备注. 以免描述时产生歧义.

上例中, 字符串 'sum 返回 x + y 的和' 和 `return` 语句尾部的注释可以追溯归属. 其它的注释仅是备注.

Z 中没有注释的注释, 所以注释 'sum 返回 x + y 的和' 尾部的注释仅是备注.

Z 中的注释是后置的, 这和其它语言不同.

语义上讲, 注释属于语句.

#表达式

表达式具有以下特征

1. 必定产生运算结果.
2. 必定存在于语句中.
3. 不能包含语句.

#语句

语句无返回值, 在 Z 源文件中最先出现的语句是注释或声明.

```
proc x out int =[
	return 5
	// Z 中的 return 是个语法糖. 它等同于两条语句
	// result = 5
	// end
]

proc noret =[
]

proc y =[
	x() // 这是非法的.
	// 因为产生了运算结果, 虽然被抛弃了可还是个表达式, 表达式不能独立存在.

	discard x() // 可以这样写, 这是一条 discard 语句.
	// Z 不会自动添加 discard, 那样看似便捷实为隐患.

	noret() // 合法, 因为没有产生运算结果
]
```

无返回值的函数调用可以形成独立的语句.
同理 Z 中匿名函数是匿名函数表达式, 因为它产生了结果.

很明显, 语句可以顺序排列或者嵌套形成语句块.

##赋值语句

赋值语句有单独的, 不存在优先级.

| 操作符 | 解释   |
|-------|--------|
| ++    |自赋值增一|
| --    |自赋值减一|
| =     |        |

前例 `proc` 声明中的 '=' 不是操作符, 是声明语法定界符.

#分隔符

逗号 ',' 用来分隔声明, 表达式以及语句.

```
var int x,y = 3+1,6     // 分隔声明变量, 分隔表达式
var []int array = [1,2] // 分隔值表达式
var (
	int i,string s      // 分隔声明变量
)

proc loop =[
	for var int x,y = 0,0; x < 10 ;x++, y = y*x[
		echo x,y
	]
]
```

三段式 `for` 语句中第一, 第三段是语句.

事实上空白也有分隔作用.

#终结符

终结符表示语句的终结.

##分号

分号 ";" 用来表示语句的结束边界. 源码经过格式美化后分号会被省略. 除非代码 minify 到一行. 

换行或者空行会依据上文的完整性推导为分号终结符. 推导规则:

	如果上文至此换行可形成完整的语句, 把换行当做分号.

*注意: 不良的换行可能引起下文非法, 甚至被当做注释.*

##定界符

定界符是一对符号, 表示代码实体的起始和终结. 有三对符号可用

	[] 数组定界
	() 分组定界
	{} 代码定界

方括号 '[]' 更便于输入, 输入时可以替代圆括号和花括号. Z 的格式美化工具会替换合适的符号.

#类型

类型名是个标识符, 预声明类型的标识符是保留字, 所有内置类型实例都是对象, 拥有内置的方法, 详见相关手册.

下面简单介绍内置类型.

##布尔

bool 的值为 true | false.

##整数

可用带符号的0-9组成的十进制, 0x开头的十六进制, 0b开头的二进制表示.

预声明的固定长度/尺寸数值类型有下面这些:

```
'
uint8       无符号的 8 位整数 (0 to 255)
uint16      无符号的 16 位整数 (0 to 65535)
uint32      无符号的 32 位整数 (0 to 4294967295)
uint64      无符号的 64 位整数 (0 to 18446744073709551615)

int8        带符号的 8 位整数 (-128 to 127)
int16       带符号的 16 位整数 (-32768 to 32767)
int32       带符号的 32 位整数 (-2147483648 to 2147483647)
int64       带符号的 64 位整数 (-9223372036854775808 to 9223372036854775807)

byte        和 uint8 一样
rune        和 int32 一样
'
```

Z 中用 byte 或 rune 类型代表单个字符. 可以用字符串对 byte 和 rune 类型进行赋值. 

```
var byte b = 'Hello Word' // b 的值为 'h'
var rune r = '世界你好'    // r 的值为 '世'
var rune e = ''          // 空字符串赋值详见下文解释
```

下列类型的长度/尺寸与运行环境有关：

```
'
uint     32 位或是 64位
int      和 uint 长度一样
'
```

##浮点数

用有符号的十进制夹杂一个"."或者 "e"表示的十进制指数.

预声明的与机器无关的数值类型有下面这些:

```
'
float32     IEEE-754 32  位浮点数
float64     IEEE-754 64  位浮点数
float128    IEEE-754 128 位浮点数
'
```

##字符串

string 是被一对单引号或者双引号包裹的多行文本.

```
proc hello out string =[
	return 'hello'
]

proc word out string =[
	return 'word'
]

var string (
	a = '单引号字符串不支持反斜杠\转义值'
		'直接断行也可以,
		换行会被保留, 前置空白会被剔除.'
		"字符串可以多行混合. 这四行组成一个字符串值"

	b = '字符串还支持嵌入参数 $a $b'.['a'=1,'b'=2]
		'SQL 参数序号风格 $1 $2'.[$a, $b]
		"变量值会被转换为字符串表示,
		这四行组成了一个字符串"

	c = hello() word() // 行内字符串表达式值连接无需运算符

	d = hello()word() // 紧凑书写也可以

	e = hello() -
		' word' // 前行尾部用 '-' 避免括号终结歧义, 否则就成注释了.

	f = '空白行会终止多字符串拼接'

        '上面有个空白行, 变量 c 的值不包括这一行'
)
```

字符串连接操作使用运算符 '-', 因为 '+' 需要 shift 按键, '-' 号更便于输入.

双引号字符串具有简单的模板功能, 双引号字符串也称作模板字符串.

```
	echo '{
			"name": "$1",
			"age": $2
		  }'.['tom', 8]
```

输出 JSON 很简单.


##日期和时间

datetime 表示日期和时间, 以 [ISO 8601][] 标准设计. 在源码中书写时使用无 '-' 间隔开年, 月, 日的基本格式.

```
var datetime(
	localdate = 20160204
	localtime = 20160204T21:49
	utcdate = 20160204Z
	utctime = 20160204T21:49Z
	zonedate = 20160204T+08 // '+' 号两端是紧凑相连的
	zonetime =  21:49+08
	now = 20160204T214900 // 简化时间格式无 ':' 号
)
```


#保留字

保留字不能被重新声明. 上文中预声明的值和类型名都是保留字.

以下关键字或类型名被保留. 

```
'
add and as asm atomic
break
case const continue
def defer
else end
for from func
go goto
has
if in is
mul
not null
or out
proc pub
range ref return
static sub
template to trait type
use
var
xor
yield
int128 uint128
'
```

#运算符

运算符只能出现在表达式中, 下表按优先级从高到低排列.

| 运算符                    | 解释           |
|--------------------------|----------------|
| $                        |仅用于模板字符串  |
| &,\|,~,xo                |位与,或,反,异或   |
| <<,>>,mod,mul,%,*,/      |                |
| add,+,-                  |                | 
| to                       |数值至数值       |
| ==,<=,>=,>,<             |比较运算         |
| not,in,is,has            |                |
| and                      |逻辑与           |
| or                       |逻辑或           |



#代码块

Z 的代码块总是以下列关键字开始嵌套子代码块.

```
'var static const func type def proc'
```

子代码块可使用的语句更丰富. 

```
type hello is example for Z =[
	string word
]
```

子代码块被包裹在方括号/圆括号中. 此例中' is example for Z ' 被忽略了,
因为在 `type` 语句中 Z 期待定界符 '=', 它之前不能识别的文本被忽略. 此例只是说明 Z 是怎么做的, 不是要推荐这样的写法.


#声明



#静态声明

值一经确定就不能改变的标识符称作静态标识, 只能进行一次赋值操作.

```zxx
static int y = 9
```

#常量声明

常量类似静态, 不同的是常量不声明类型, 只声明值, 可用的值类型有字符串, 数值, 布尔值, 时间值.

```
const (
	CRLF = "\r\n"
	ZERO = 0
	DAY  = 20110101T
	ONE  = 1.0
	YES  = true
)
```


#变量声明

```
var (
	byte   b = CRLF
	string s = CRLF
	rune   r = CRLF
)
```

#类型声明

```
type 
```

#过程声明

函数, 类型方法统称为过程

#表达式

表达式的作用是运算并产生结果, 由标识符和运算符组成.

#语句



##if 语句

```
if [
]
```
add and as asm atomic
break
case const continue
def defer
else end
for from func
go goto
if in is
not null
of or out
proc pub
range ref return
shl shr static sub
template to trait type
use
var
xor
yield

#声明和作用域



#源文件组织

以颗粒度从大到小 Z 可划分为:

1. 项目     项目这就是一个 git 仓库
2.     包     项目下的子目录, 同目录下也可以存在不同的包
3. 文件      一个或多个文件组成包

Z 依靠目录名, 文件名组织源代码, 执行的规则如下:

1. 目录名或者文件名由 [a-z]+[a-z0-9-_]* 组成.
2. 目录名以减号 '-' 分割, 第一段为该目录包名.
3. 文件名以减号 '-' 分割, 第一段为该文件所属包名, 没有减号表示使用目录包名.
4. 文件名可后缀平台和架构, 以 '_' 连接.
5. 文件扩展名采用 'md' 和 'zxx'

	hello.md
	hello.zxx
	hello-word_linux.zxx

就是说包名称由 26 个小写英文字母和 0-9 数字组成, 并且以字母开头.
一些特殊的名称被用于工具链

1. main 可执行单元
2. test 测试单元
3. example 样例单元
4. benchmark 评测单元
5. hack  只能被 main 单元使用.

某些时候需要修改某个依赖包, 但是却无权提交代码, 那么无需等待维护者更新, 也无需修改依赖包源码, 自己写个外部的 hack 单元就可以替换掉原包中的代码. 

文件名中的包名和子目录重名举例:

```
rep
├── hello/
├── block.json
└── hello-word.md
```

rep 下有子目录包名 hello,  hello-word.md 也使用包名 hello,  这相当于上层目录 hack 了下层目录的包.

##block.json

上例的 Z 源码目录下有一个 'block.json' 文件, 用来描述该目录下的源码情况.
文件名使用 'block' 而不是 'package' 是因为 Z 中没有 package 概念, 只有块.
虽然为便于描述使用了仓库, 项目, 包这些具有颗粒度的词, 但事实上都是块. 

'block.json' 的采用语义化属性名, 通常这无需特别解释, 看到名称就知道作用.

```JSON
{
	"name": "zxxlang",
	"license": "BSD-3-Clause",
	"version": "0.0.0",
	"repository": {
		"type": "git",
		"url": "https://github.com/zxxLang/zxx.git"
	},
	"keywords": [
		"zxx"
	],
	"author": {
		"name": "YU HengChun",
		"url": "http://achun.github.io/"
	}
}
```

[ISO 8601]: https://en.wikipedia.org/wiki/ISO_8601